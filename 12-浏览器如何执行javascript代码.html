<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>12-浏览器如何执行javascript代码</title>
</head>

<body>
  <h1>JavaScript编译过程：</h1>
  <div>
    <img width="600" src="./images/javascript浏览器与运行过程.png" alt="">


  </div>

  <script>
    /*
    *内存管理
    JavaScript 引擎的内存空间分为堆（Heap）和栈（Stack）。堆和栈是两种不同的数据结构，堆是具有树结构的数组，栈也是数组，但是遵循“先进后出”规则。

    栈

    栈是一个临时存储空间，主要存储局部变量和函数调用（对于全局表达式会创建匿名函数并调用）。

    对于基本数据类型（String、Undefined、Null、Boolean、Number、BigInt、Symbol）的局部变量，会直接在栈中创建，而对象数据类型局部变量会存储在堆中，
    栈中只存储它的引用地址，也就是我们常说的浅拷贝。全局变量以及闭包变量也是只存储引用地址。总而言之栈中存储的数据都是轻量的

    对于函数，解释器创建了“调用栈”（Call Stack）来记录函数的调用流程。每调用一个函数，解释器就会把该函数添加进调用栈，
    解释器会为被添加进的函数创建一个栈帧 （Stack Frame，这个栈帧用来保存函数的局部变量以及执行语句）并立即执行。如果正在执行的函数还调用了其它函数，
    那么新函数也将会被添加进调用栈并执行。一旦这个函数执行结束，对应的栈帧也会被立即销毁。

    查看调用栈的方式有 2 种：

      调用函数 console.trace() 打印到控制台；
      利用浏览器开发者工具进行断点调试。
    
    堆

    堆空间存储的数据比较复杂，大致可以划分为下面 5 个区域：代码区（Code Space）、Map 区(Map Space)、大对象区（Large Object Space）、
    新生代（New Space）、老生代（Old Space）。这一课时重点讨论新生代和老生代的内存回收算法。

    栈可以看作一个按照顺序排列的消息数据（事件）集合。

    这个集合可以看作是一个内部嵌套了一个方法的函数，
    而这个内部方法又嵌套了一个方法，就这么嵌套了N层。
    当执行这个方法时，需要先执行内部的方法，也就是要先执行最内部的方法，然后就是等内部的一层层方法按照嵌套层级的反向顺序执行完毕，才能执行最外层的方法。

    所以当你执行这么一个方法（栈）时，就是要先执行“最后来的方法”，所以叫做先进后出。

    JavaScript是单线程语言，主线程执行同步代码。 
    函数调用时， 便会在内存中形成了一个“调用记录”， 又称“调用帧”， 保存调用位置和内部变量等信息。 如果函数内部还调用了其他函数，那么在调用记录上方又会形成一个调用记录，
    所有的调用记录就形成一个“调用栈”。（闭包、尾调用、尾递归优化）

    队列 （先进先出）

    队列也可以看作是指一个按照顺序排列的消息事件集合。

    区别就是队列像一个直线单向传送带，先传送到终点的物品，先进行处理。

    总结与拓展：

    javaScript是单线程的，不能同时执行多个任务，单线程就意味着所有任务需要排队。
    但是在javaScript里面，很多时候阻止线程运行的很慢的是网络IO之类；
    这时候CPU是空闲的，这样就会造成资源的浪费，所以javaScript在主线程之外实现了一个任务队列，
    像IO之类比较慢的操作暂时都会挂在任务队列上，这样不会影响到主线程上任务的执行，
    等到IO的响应回来后再回到主线程上来执行挂起的任务。
    比如Ajax请求、定时器等、UI事件等都会先进入到任务队列上，而不是挂在主线程上。 

    任务队列里的每个任务都可以看作是一个由多个事件组成的（任务）栈，所以这个任务队列就可以看作一个由多个（任务）栈组成的队列，
    当这个队列中的某一个（任务）栈执行完毕（清空）以后，就会把这个（任务）栈移除，然后在主线程上面执行该（任务）栈返回的最终消息。
    这个处理过程包含了调用与这个消息相关联的函数（以及因而创建的一系列初始堆栈帧）。
    当栈为空的时候，也就意味着消息处理结束。
    这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

    JS是单线程， 主线程执行同步代码， 事件、I/O操作等异步任务，将会进入任务队列执行，异步执行有结果之后，就会变为等待状态， 形成一个事件，
    主线程的同步代码执行完之后，再从”任务队列”中读取事件， 执行事件异步任务的回调。 
    这就是为什么执行顺序是， 同步 > 异步 > 回调 
    更简单的说：只要主线程空了（同步），就会去读取”任务队列”（异步），这就是JavaScript的运行机制。
    

    */



  </script>

</body>

</html>