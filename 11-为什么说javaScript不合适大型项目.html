<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>为什么说Javascript不适合大型项目?</title>
</head>

<body>

  <script>

    /*
      *
      1. 类型声明
      前面在第 08 课时中已经提过命名的提升特性，如果某个变量命名提升到全局，那么将是危险的。比如下面的代码，函数 fn 内部使用了一个变量 c，由于忘记使用关键字来声明，结果导致覆盖了全局变量 c。
      var c = 0
      function fn() {
        c = 30;
      }
      fn();
      
      2. 动态类型
      动态类型是指在运行期间才做数据类型检查的语言，即动态类型语言编程时，不用给任何变量指定数据类型。

      3. 弱类型

      弱类型是指一个变量可以被赋予不同数据类型的值。这也是一个既灵活又可怕的特性，编写代码的时候非常方便，不用考虑变量的数据类型，但这也很容易出现 bug，调试起来会变得相当困难。
      
      为了解决上面 3 个问题，开源社区提供了解决方案——TypeScript。它是基于 JavaScript 的语法糖，也就是说 TypeScript 代码没有单独的运行环境，需要编译成 JavaScript 代码之后才能运行。
      从它的名字不难看出，它的核心特性是类型“Type”。具体工作原理就是在代码编译阶段进行类型检测，这样就能在代码部署运行之前及时发现问题。
    
    */

    {
      console.log('-------------');
      var tmp = []
      tmp = null
      console.log(tmp); //nu;; 





    }

    {
      console.log('-------------类型与接口---------------');

      /*
        TypeScript 让 JavaScript 变成了静态强类型****、变量需要严格声明的语言，为此定义了两个重要概念：类型（type）和接口（interface）。

        TypeScript 在 JavaScript 原生类型的基础上进行了扩展，但为了和基础类型对象进行区分，采用了小写的形式，比如 Number 类型对应的是 number。类型之间可以互相组合形成新的类型。

        一些数据类型在前面第 07 课时中已经提过，这里不再赘述。下面补充一下 TypeScript 扩展的类型。

        1.元组
        元组可以看成是具有固定长度的数组，其中数组元素类型可以不同。比如下面的代码声明了一个元组变量 x，x 的第一个元素是字符串，第二个是数字；又比如 react hooks 就是用到了元组类型。

        let x: [string, number];

        2. 枚举
        枚举指的是带有名字的常量，可以分为数字枚举、字符串枚举和异构枚举（字符串和数字的混合）3 种。比较适用于前后端通用的枚举值，比如通过 AJAX 请求获取的数据状态，对于仅在前端使用的枚举值还是推荐使用 Symbol。

        3.any
        any 类型代表可以是任何一种类型，所以会跳过类型检查，相当于让变量或返回值又变成弱类型。因此建议尽量减少 any 类型的使用。

        4.void
        void 表示没有任何类型，常用于描述无返回值的函数。

        never 类型表示的是那些永不存在的值的类型，对于一些特殊的校验场景比较有用，比如代码的完整性检查。下面的示例代码通过穷举判断变量 u 的值来执行对应逻辑，如果此时变量 u 的可选值新增了字符串 "c"，那么这段代码并不会给出提示告诉开发者还有一种 u 等于字符串 "c" 的场景，但如果增加 never 类型赋值的话在编译时就可以给出提示。

        接口的作用和类型非常相似，在大多数情况下可以通用，只存在一些细小的区别（比如同名接口可以自动合并，而类型不能；在编译器中将鼠标悬停在接口上显示的是接口名称，悬停在类型上显示的是字面量类型），最明显的区别还是在写法上。

        泛型是对类型的一种抽象，一般用于函数，能让调用者动态地指定部分数据类型。这一点和 any 类型有些像，对于类型的定义具有不确定性，可以指代多种类型，但最大区别在于泛型可以对函数成员或类成员产生约束关系。

        总结
        这一课时重点讲述了如何通过 TypeScript 来解决 JavaScript 的类型问题，TypeScript 在原有的基础类型上进行了扩展，理解 TypeScript 的基本类型并不难，重点需要掌握如何通过泛型来对类型进行抽象，如何通过组合及引用来对已有的类型创建新的类型。

      

      */
      // enum example {
      //   No = 0,
      //   Yes = "YES",
      // }
      // console.log(example.No)
      // // 编译成
      // var example;
      // (function (example) {
      //   example[example["No"] = 0] = "No";
      //   example["Yes"] = "YES";
      // })(example || (example = {}));
      // console.log(example.No);
      // ////////////
      // const enum example {
      //   No = 0,
      //   Yes = "YES",
      // }
      // console.log(example.No)
      // //  编译成
      // console.log(0 /* No */);

      















    }


    


  </script>




</body>

</html>